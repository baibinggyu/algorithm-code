# 二进制集合与子集枚举笔记（通用版）

------

## 1️⃣ 概念

- 用整数表示集合：
  - 二进制位为 1 → 元素存在
  - 二进制位为 0 → 元素不存在
- **子集定义**：
   [
   s \text{ 是 } i \text{ 的子集 } \iff (s & i) == s
   ]
   也就是 s 的所有元素都在 i 中。

------

## 2️⃣ 枚举子集的公式（通用）

对于任意集合 `i`（用二进制表示）：

```
s = i
while s != 0:
    # 使用 s
    s = (s - 1) & i
```

### 解释

1. `(s - 1)`：将 s 最右边的 1 变为 0，右边 0 变为 1
2. `& i`：保证子集仍然在 i 的范围内（合法子集）
3. 循环遍历，直到 s = 0（空集）

------

## 3️⃣ 举例

假设 `i = 1011₂`（十进制 11）：

枚举过程：

```
s = 1011 → 输出
s = (1011-1)&1011 = 1010 → 输出
s = (1010-1)&1011 = 1001 → 输出
s = (1001-1)&1011 = 1000 → 输出
s = (1000-1)&1011 = 0011 → 输出
s = (0011-1)&1011 = 0010 → 输出
s = (0010-1)&1011 = 0001 → 输出
s = (0001-1)&1011 = 0000 → break
```

✅ 得到 i 的全部子集：`1011, 1010, 1001, 1000, 0011, 0010, 0001, 0000`

------

## 4️⃣ 性质

- 枚举顺序从大到小（按二进制数值）
- 不重复、不遗漏，每个子集只出现一次
- 枚举数量 = (2^{\text{popcount(i)}})
  - popcount(i) = i 的二进制 1 的个数
- 适用范围：
  - 1-bit 数量较少时（≤ 20~22），效率极高
  - 可处理大整数集合，只要 1-bit 数量不多

------

## 5️⃣ 使用场景

- **统计子集属性**：如符合某条件的子集数量
- **组合计数优化**：判断 C(i,j) 奇偶性 `(i & j) == j`
- **动态规划与位运算**：枚举状态的子集，避免 O(n²) 暴力

------

## 6️⃣ 核心结论

1. `(s-1) & i` 是 **枚举 i 所有子集的标准公式**
2. 每个 s 都是合法子集
3. 枚举从 i → 0，覆盖全部 (2^{popcount(i)}) 个子集
4. 可配合条件过滤，例如 `s >= a`、满足特定位模式等
5. 可用于任何语言，算法思想通用，不依赖 Java

------

## 7️⃣ 小技巧

- 如果只需统计数量，不必存数组，直接 `count++`
- 枚举顺序是递减，可方便做 DP 或计数优化
- 对大范围集合，子集数量指数级增长，注意 popcount 限制
- 通用公式可扩展到任意位集合、状态压缩问题

------

**总结**：

> `(s-1) & i` 是位运算中 **高效、通用的子集枚举技巧**，理解原理后可应用于数论、组合、动态规划等多种算法问题。